<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>竖直弹簧振子简谐运动实验</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 5px;
            background-color: #f0f8ff;
        }
        html {
            height: 100%;
        }
        .title-container {
            display: flex;
            justify-content: center;
            align-items: baseline;
            margin-bottom: 5px;
        }
        h1 {
            margin: 0;
            color: #007bff;
        }
        .designer {
            font-size: 20px;
            color: #2401e9;
            margin-left: 20px;
            font-family: 'Brush Script MT', cursive;
            font-style: italic;
        }
        .button-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px auto 0;
            justify-content: center;
            width: 95vw;
            padding: 0;
            flex-shrink: 0;
        }
        .charts-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 132px);
            gap: 10px;
            padding: 10px;
        }
        .chart-wrapper {
            flex: 1;
            position: relative;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .green-button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
        }
        .green-button:hover {
            background-color: #218838;
        }
        .green-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .value-display {
            margin-left: 20px;
            font-size: 24px;
            font-weight: bold;
            padding: 10px 20px;
            background-color: #e6f3ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            min-width: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #007bff;
        }
        .drag-mode-button {
            background-color: #28a745;  /* 默认使用绿色 */
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
        }
        .drag-mode-button.selecting {
            background-color: #007bff;  /* 选中状态使用蓝色 */
        }
        .zoom-mode-button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
        }
        .analysis-container {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            margin-bottom: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .analysis-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .analysis-button {
            padding: 0.8vh 1.5vw;
            font-size: clamp(0.75rem, 1.2vw, 0.875rem);
            border: 1px solid #dee2e6;
            border-radius: 4px;
            white-space: nowrap;
            color: #6c757d;
            background-color: #f8f9fa;
            cursor: not-allowed;
            transition: all 0.2s;
        }
        .analysis-button.enabled {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            cursor: pointer;
        }
        .analysis-button.enabled:hover {
            background-color: #0056b3;
            border-color: #004085;
        }
        .analysis-result {
            font-size: clamp(0.875rem, 1.5vw, 1rem);
            min-width: 150px;
            flex: 1;
            text-align: left;
            color: #000000;
            margin-left: 10px;
            padding: 2px 0;
        }
        .secondary-buttons {
            display: none;
            gap: 8px;
            margin-top: 8px;
        }
        .secondary-button {
            padding: 6px 12px;
            font-size: 14px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.2s;
        }
        .secondary-button:hover {
            background-color: #e9ecef;
        }
        .secondary-button.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <h1>竖直弹簧振子简谐运动实验（基于力传感器）</h1>
        <span class="designer">杨燕琨老师设计</span>
    </div>
    <div class="button-container">
        <div class="button-group">
            <button id="connectButton" class="green-button">连接传感器</button>
            <button id="drawAndDataButton" class="green-button" disabled>采集数据</button>
            <button id="clearDataButton" class="green-button">清除数据</button>
            <button id="exportDataButton" class="green-button">保存数据</button>
            <button id="dragModeButton" class="drag-mode-button">图像拖动模式</button>
            <button id="zoomModeButton" class="zoom-mode-button">整体缩放</button>
        </div>
        <div id="valueDisplayButton" class="value-display">位移: 0.0 cm</div>
    </div>
    <div class="charts-container">
        <div class="chart-wrapper">
            <canvas id="displacementChart"></canvas>
        </div>
        <div class="chart-wrapper">
            <canvas id="velocityChart"></canvas>
        </div>
        <div class="chart-wrapper">
            <canvas id="accelerationChart"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script>
        let charts = {};
        let bluetoothDevice;
        let characteristic;
        let isDrawingChart = false;
        let receivingData = false;
        let dataBuffer = {
            displacement: [],
            velocity: [],
            acceleration: []
        };
        
        // 修改滤波窗口大小，使用适中的平滑强度，经过调试最优值 
        const DISPLACEMENT_FILTER_SIZE = 4;   // 从15减小到5        
        const VELOCITY_FILTER_SIZE = 8;      // 从21减小到8
        const ACCELERATION_FILTER_SIZE = 9;  // 从31减小到15
        
        // 添加更新频率控制
        const UPDATE_INTERVAL = 50; // 50ms更新一次图表
        let lastUpdateTime = 0;
        
        // 优化的滑动平均滤波函数
        function movingAverageFilter(data, windowSize) {
            if (data.length < windowSize) return data;
            
            const filtered = new Array(data.length);
            const halfWindow = Math.floor(windowSize / 2);
            
            // 预计算窗口和
            let sum = 0;
            for (let i = 0; i < windowSize; i++) {
                sum += data[i].y;
            }
            
            // 第一个点
            filtered[0] = {
                x: data[0].x,
                y: sum / windowSize
            };
            
            // 滑动窗口计算
            for (let i = 1; i < data.length - windowSize + 1; i++) {
                sum = sum - data[i - 1].y + data[i + windowSize - 1].y;
                filtered[i] = {
                    x: data[i].x,
                    y: sum / windowSize
                };
            }
            
            // 填充剩余点
            for (let i = data.length - windowSize + 1; i < data.length; i++) {
                filtered[i] = {
                    x: data[i].x,
                    y: filtered[i - 1].y
                };
            }
            
            return filtered;
        }

        // 优化的导数计算函数
        function calculateDerivative(data, filterSize) {
            if (data.length < 2) return [];
            
            const derivatives = new Array(data.length - 1);
            
            // 计算导数
            for (let i = 1; i < data.length; i++) {
                derivatives[i - 1] = {
                    x: data[i].x,
                    y: (data[i].y - data[i - 1].y) / (data[i].x - data[i - 1].x)
                };
            }
            
            // 对导数进行滤波
            const filtered = movingAverageFilter(derivatives, filterSize);
            
            // 如果是计算速度，将cm/s转换为m/s
            if (filterSize === VELOCITY_FILTER_SIZE) {
                filtered.forEach(point => {
                    point.y = point.y / 100; // cm/s 转换为 m/s
                });
            }
            // 如果是计算加速度，将cm/s²转换为m/s²
            else if (filterSize === ACCELERATION_FILTER_SIZE) {
                filtered.forEach(point => {
                    point.y = point.y / 100; // cm/s² 转换为 m/s²
                });
            }
            
            return filtered;
        }

        // 修改回简单的正弦拟合函数
        function sineFit(data) {
            if (!data || data.length < 10) return null;
            
            // 计算平均值
            const mean = data.reduce((sum, point) => sum + point.y, 0) / data.length;
            
            // 寻找波峰和波谷来估计振幅
            let max = -Infinity;
            let min = Infinity;
            data.forEach(point => {
                max = Math.max(max, point.y);
                min = Math.min(min, point.y);
            });
            const amplitude = (max - min) / 2;
            
            // 估计周期
            let crossings = [];
            for (let i = 1; i < data.length; i++) {
                if ((data[i-1].y - mean) * (data[i].y - mean) <= 0) {
                    crossings.push(data[i].x);
                }
            }
            
            if (crossings.length < 2) return null;
            
            // 计算周期
            let periods = [];
            for (let i = 2; i < crossings.length; i += 2) {
                periods.push(crossings[i] - crossings[i-2]);
            }
            const period = periods.reduce((sum, p) => sum + p, 0) / periods.length;
            
            // 计算角频率
            const omega = 2 * Math.PI / period;
            
            // 计算相位
            const t0 = data[0].x;
            const phase = Math.asin((data[0].y - mean) / amplitude);
            
            // 生成更密集的拟合数据点
            const startTime = data[0].x;
            const endTime = data[data.length - 1].x;
            const numPoints = 300; // 生成300个点以获得平滑的拟合曲线
            const timeStep = (endTime - startTime) / (numPoints - 1);
            
            const fittedData = [];
            for (let i = 0; i < numPoints; i++) {
                const x = startTime + i * timeStep;
                fittedData.push({
                    x: x,
                    y: mean + amplitude * Math.sin(omega * (x - t0) + phase)
                });
            }
            
            return {
                fittedData,
                parameters: {
                    mean: mean.toFixed(3),
                    amplitude: amplitude.toFixed(3),
                    period: period.toFixed(3),
                    frequency: (1/period).toFixed(3),
                    phase: (phase * 180 / Math.PI).toFixed(1)
                }
            };
        }

        // 修改 drawAndDataButton 的点击事件处理
        document.getElementById('drawAndDataButton').addEventListener('click', () => {
            if (!bluetoothDevice?.gatt.connected) return;
            
            isDrawingChart = !isDrawingChart;
            receivingData = isDrawingChart;
            
            if (isDrawingChart) {
                drawAndDataButton.textContent = '停止采集';
                // 清空数据缓冲区
                dataBuffer = {
                    displacement: [],
                    velocity: [],
                    acceleration: []
                };
                // 清空图表
                Object.values(charts).forEach(chart => {
                    chart.data.datasets[0].data = [];
                    chart.update();
                });
                // 启动通知和更新
                characteristic.startNotifications()
                    .then(() => {
                        console.log('开始数据采集');
                        requestAnimationFrame(updateCharts);
                    });
            } else {
                drawAndDataButton.textContent = '采集数据';
                characteristic.stopNotifications()
                    .then(() => {
                        console.log('停止数据采集');
                    });
            }
        });

        // 修改图表更新函数
        function updateCharts() {
            const currentTime = performance.now();
            if (currentTime - lastUpdateTime < UPDATE_INTERVAL) {
                if (isDrawingChart) {
                    requestAnimationFrame(updateCharts);
                }
                return;
            }
            lastUpdateTime = currentTime;

            // 计算完整处理一个数据点所需的总延迟点数
            // 位移滤波 + 速度计算和滤波 + 加速度计算和滤波
            const totalDelay = DISPLACEMENT_FILTER_SIZE + VELOCITY_FILTER_SIZE + ACCELERATION_FILTER_SIZE;
            
            // 确保有足够的数据点再开始绘制
            if (dataBuffer.displacement.length < totalDelay + 10) { // 额外加10个点作为安全边界
                if (isDrawingChart) {
                    requestAnimationFrame(updateCharts);
                }
                return;
            }

            // 制数据点数量
            const MAX_POINTS = 1000;
            if (dataBuffer.displacement.length > MAX_POINTS) {
                const startIdx = dataBuffer.displacement.length - MAX_POINTS;
                dataBuffer.displacement = dataBuffer.displacement.slice(startIdx);
            }

            // 处理数据
            const filteredDisplacement = movingAverageFilter(dataBuffer.displacement, DISPLACEMENT_FILTER_SIZE);
            const velocity = calculateDerivative(filteredDisplacement, VELOCITY_FILTER_SIZE);
            const acceleration = calculateDerivative(velocity, ACCELERATION_FILTER_SIZE);

            // 只显示完全处理好的数据点
            // 从最新的数据点往回推 totalDelay 个点
            const validEndIndex = acceleration.length - totalDelay;
            const validStartIndex = Math.max(0, validEndIndex - MAX_POINTS);

            // 确保所有图表使用相同的时间范围
            const validTime = {
                start: acceleration[validStartIndex]?.x,
                end: acceleration[validEndIndex]?.x
            };

            // 只显示在有效时间范围内的数据
            const finalDisplacement = filteredDisplacement.filter(
                p => p.x >= validTime.start && p.x <= validTime.end
            );
            const finalVelocity = velocity.filter(
                p => p.x >= validTime.start && p.x <= validTime.end
            );
            const finalAcceleration = acceleration.filter(
                p => p.x >= validTime.start && p.x <= validTime.end
            );

            // 更新图表数据
            charts.displacement.data.datasets[0].data = finalDisplacement;
            charts.velocity.data.datasets[0].data = finalVelocity;
            charts.acceleration.data.datasets[0].data = finalAcceleration;

            // 如果有数据点可以显示
            if (finalAcceleration.length > 0) {
                // 更新 X 轴范围
                const xMax = validTime.end;
                
                Object.values(charts).forEach(chart => {
                    // 设置 X 轴范围
                    chart.options.scales.x.min = xMax - 10; // 显示最近10秒的数据
                    chart.options.scales.x.max = xMax + 1;  // 预留1秒空间

                    // 自动调整 Y 轴范围
                    const data = chart.data.datasets[0].data;
                    if (data.length > 0) {
                        const yValues = data.map(p => p.y);
                        const yMin = Math.min(...yValues);
                        const yMax = Math.max(...yValues);
                        const yRange = yMax - yMin;
                        chart.options.scales.y.min = yMin - yRange * 0.1;
                        chart.options.scales.y.max = yMax + yRange * 0.1;
                    }

                    chart.update('none');
                });
            }

            if (isDrawingChart) {
                requestAnimationFrame(updateCharts);
            }
        }

        // 优化数据处理函数
        function handleData(event) {
            if (!receivingData) return;

            const value = event.target.value;
            const dataView = new DataView(value.buffer);
            const displacement = dataView.getFloat32(0, true);
            const time = dataView.getFloat32(4, true);

            // 添加新数据点
            if (isDrawingChart) {
                dataBuffer.displacement.push({ x: time, y: displacement });
                
                // 计算处理后的最新位移值
                const totalDelay = DISPLACEMENT_FILTER_SIZE + VELOCITY_FILTER_SIZE + ACCELERATION_FILTER_SIZE;
                if (dataBuffer.displacement.length >= totalDelay + 10) {
                    const filteredDisplacement = movingAverageFilter(dataBuffer.displacement, DISPLACEMENT_FILTER_SIZE);
                    const validValue = filteredDisplacement[filteredDisplacement.length - totalDelay - 1];
                    if (validValue) {
                        document.getElementById('valueDisplayButton').textContent = 
                            `位移: ${validValue.y.toFixed(1)} cm`;
                    }
                }
                
                // 只在没有待处理的更新时请求新的更新
                if (!lastUpdateTime || performance.now() - lastUpdateTime >= UPDATE_INTERVAL) {
                    requestAnimationFrame(updateCharts);
                }
            }
        }

        async function connectToSensor() {
            try {
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'yykdislab' }],
                    optionalServices: ['cddf1001-30f7-4671-8b43-5e40ba53514a']
                });

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService('cddf1001-30f7-4671-8b43-5e40ba53514a');
                characteristic = await service.getCharacteristic('cddf1002-30f7-4671-8b43-5e40ba53514a');

                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', handleData);

                connectButton.textContent = '断开传感器';
                connectButton.removeEventListener('click', connectToSensor);
                connectButton.addEventListener('click', disconnectFromSensor);
                drawAndDataButton.disabled = false;

            } catch (error) {
                console.error('连接错误:', error);
                await disconnectFromSensor();
            }
        }

        async function disconnectFromSensor() {
            if (bluetoothDevice?.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
            }
            connectButton.textContent = '连接传感器';
            connectButton.removeEventListener('click', disconnectFromSensor);
            connectButton.addEventListener('click', connectToSensor);
            drawAndDataButton.disabled = true;
            isDrawingChart = false;
            receivingData = false;
        }

        // 初始事件监听器
        document.getElementById('connectButton').addEventListener('click', connectToSensor);
        
        document.getElementById('clearDataButton').addEventListener('click', () => {
            dataBuffer = {
                displacement: [],
                velocity: [],
                acceleration: []
            };
            Object.values(charts).forEach(chart => {
                chart.data.datasets[0].data = [];
                chart.update();
            });
        });

        document.getElementById('exportDataButton').addEventListener('click', () => {
            const data = dataBuffer.displacement.map((point, i) => ({
                time: point.x,
                displacement: point.y,
                velocity: dataBuffer.velocity[i]?.y || '',
                acceleration: dataBuffer.acceleration[i]?.y || ''
            }));

            const csv = [
                ['时间 (s)', '位移 (cm)', '速度 (cm/s)', '加速度 (cm/s²)'],
                ...data.map(row => [row.time, row.displacement, row.velocity, row.acceleration])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '弹簧振子实验数据.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // 添加全局变量
        let isSelectMode = false;
        let isXAxisZoomMode = false;
        let currentChartContext = null; // 记录当前操作的图表上下文
        let selectionStart = {};
        let selectionEnd = {};
        let selectedData = {};
        let selectionVisible = {};

        // 添加选择区域插件
        const selectionPlugin = {
            id: 'selection',
            beforeDraw: (chart) => {
                const chartId = chart.canvas.id;
                if ((isSelectMode || selectionVisible[chartId]) && 
                    selectionStart[chartId] && selectionEnd[chartId]) {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    
                    const startX = chart.scales.x.getPixelForValue(selectionStart[chartId].x);
                    const endX = chart.scales.x.getPixelForValue(selectionEnd[chartId].x);
                    
                    ctx.save();
                    ctx.fillStyle = 'rgba(135, 206, 235, 0.2)';
                    ctx.strokeStyle = 'rgba(135, 206, 235, 0.5)';
                    ctx.lineWidth = 1;
                    
                    ctx.fillRect(
                        Math.min(startX, endX),
                        chartArea.top,
                        Math.abs(endX - startX),
                        chartArea.bottom - chartArea.top
                    );
                    
                    ctx.strokeRect(
                        Math.min(startX, endX),
                        chartArea.top,
                        Math.abs(endX - startX),
                        chartArea.bottom - chartArea.top
                    );
                    
                    ctx.restore();
                }
            }
        };

        // 添加积分区域插件
        const integralAreaPlugin = {
            id: 'integralArea',
            beforeDraw: (chart) => {
                const chartId = chart.canvas.id;
                if (chart.showIntegralArea && selectedData[chartId]) {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    const firstPoint = selectedData[chartId][0];
                    let startX = chart.scales.x.getPixelForValue(firstPoint.x);
                    let startY = chart.scales.y.getPixelForValue(0);
                    
                    ctx.moveTo(startX, startY);
                    
                    selectedData[chartId].forEach(point => {
                        const x = chart.scales.x.getPixelForValue(point.x);
                        const y = chart.scales.y.getPixelForValue(point.y);
                        ctx.lineTo(x, y);
                    });
                    
                    const lastPoint = selectedData[chartId][selectedData[chartId].length - 1];
                    let endX = chart.scales.x.getPixelForValue(lastPoint.x);
                    ctx.lineTo(endX, startY);
                    
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
        };

        // 改initializeCharts函数
        function initializeCharts() {
            Chart.register(selectionPlugin);
            Chart.register(integralAreaPlugin);

            const chartConfigs = {
                displacement: {
                    label: '位移',
                    color: '#007bff',
                    unit: 'cm·s'
                },
                velocity: {
                    label: '速度',
                    color: '#28a745',
                    unit: 'm'
                },
                acceleration: {
                    label: '加速度',
                    color: '#dc3545',
                    unit: 'm/s'
                }
            };

            Object.entries(chartConfigs).forEach(([type, config]) => {
                const canvas = document.getElementById(`${type}Chart`);
                const ctx = canvas.getContext('2d');
                
                // 为每个图表添加鼠标事件监听器
                canvas.addEventListener('mousedown', (e) => startDragging(e, type));
                canvas.addEventListener('mousemove', (e) => drag(e, type));
                canvas.addEventListener('mouseup', (e) => stopDragging(e, type));
                canvas.addEventListener('mouseleave', (e) => stopDragging(e, type));
                canvas.addEventListener('wheel', (e) => handleWheel(e, type));

                // 初始化选择状态
                selectionStart[`${type}Chart`] = null;
                selectionEnd[`${type}Chart`] = null;
                selectedData[`${type}Chart`] = null;
                selectionVisible[`${type}Chart`] = false;

                charts[type] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: config.label,
                            data: [],
                            borderColor: config.color,
                            tension: 0.2,
                            pointRadius: 0,
                            borderWidth: 2,
                            spanGaps: true
                        }, {
                            label: '正弦拟合',
                            data: [],
                            borderColor: 'red',
                            borderWidth: 2,
                            pointRadius: 0,
                            hidden: true,
                            display: false,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        elements: {
                            line: {
                                tension: 0.2
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    filter: function(legendItem, data) {
                                        // 只显示物理量名称和正弦拟合的图例
                                        return (legendItem.text === config.label) || 
                                               (legendItem.text === '正弦拟合' && 
                                                data.datasets[1].data.length > 0 && 
                                                !data.datasets[1].hidden);
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: '时间 (s)'
                                },
                                min: 0,
                                max: 10
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: type === 'displacement' ? '位移 (cm)' :
                                         type === 'velocity' ? '速度 (m/s)' :
                                         '加速度 (m/s²)'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            });
        }

        // 修改鼠标事件处理函数
        function startDragging(e, chartType) {
            if (e.button !== 0) return;
            
            const chartId = `${chartType}Chart`;
            currentChartContext = chartId;
            isDragging = true;
            
            const chart = charts[chartType];
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isSelectMode) {
                // 清除所有图表的选择
                Object.keys(charts).forEach(type => {
                    const id = `${type}Chart`;
                    selectionStart[id] = null;
                    selectionEnd[id] = null;
                    selectionVisible[id] = false;
                    selectedData[id] = null;
                    charts[type].showIntegralArea = false;
                    charts[type].update();
                });
                
                // 开始新的选择
                selectionStart[chartId] = {
                    x: chart.scales.x.getValueForPixel(x),
                    y: chart.scales.y.getValueForPixel(y)
                };
                selectionEnd[chartId] = selectionStart[chartId];
                
                // 清除分析结果
                document.getElementById('analysisResult').textContent = '';
                
                // 禁用分析按钮
                const buttons = document.querySelectorAll('.analysis-button');
                buttons.forEach(button => {
                    button.classList.remove('enabled');
                    button.disabled = true;
                });
            } else {
                startX = x;
                startY = y;
                startXMin = chart.scales.x.min;
                startXMax = chart.scales.x.max;
                startYMin = chart.scales.y.min;
                startYMax = chart.scales.y.max;
            }
        }

        function drag(e, chartType) {
            const chartId = `${chartType}Chart`;
            if (chartId !== currentChartContext || !isDragging) return;
            
            const chart = charts[chartType];
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isSelectMode) {
                // 选择式
                selectionEnd[chartId] = {
                    x: chart.scales.x.getValueForPixel(x),
                    y: chart.scales.y.getValueForPixel(y)
                };
            } else {
                // 拖动模式
                const deltaX = x - startX;
                const deltaY = y - startY;
                const chartArea = chart.chartArea;
                
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                
                const deltaXData = (deltaX / chartArea.width) * (startXMax - startXMin);
                const deltaYData = (deltaY / chartArea.height) * (startYMax - startYMin);
                
                chart.options.scales.x.min = startXMin - deltaXData;
                chart.options.scales.x.max = startXMax - deltaXData;
                chart.options.scales.y.min = startYMin + deltaYData;
                chart.options.scales.y.max = startYMax + deltaYData;
            }
            
            chart.update('none');
        }

        function stopDragging(e, chartType) {
            const chartId = `${chartType}Chart`;
            if (chartId !== currentChartContext) return;
            
            if (isSelectMode && isDragging && selectionStart[chartId] && selectionEnd[chartId]) {
                const minX = Math.min(selectionStart[chartId].x, selectionEnd[chartId].x);
                const maxX = Math.max(selectionStart[chartId].x, selectionEnd[chartId].x);
                
                selectedData[chartId] = charts[chartType].data.datasets[0].data.filter(
                    point => point.x >= minX && point.x <= maxX
                );
                
                selectionVisible[chartId] = true;
                
                // 检查是否有任何图表有选中的数据
                const hasAnySelection = Object.values(selectedData).some(data => data && data.length > 0);
                
                // 更新按钮状态
                const buttons = document.querySelectorAll('.analysis-button');
                buttons.forEach(button => {
                    if (hasAnySelection) {
                        button.classList.add('enabled');
                        button.disabled = false;
                    } else {
                        button.classList.remove('enabled');
                        button.disabled = true;
                    }
                });
            }
            
            isDragging = false;
            currentChartContext = chartId;  // 保持当前图表上下文
        }

        // 修改handleWheel函数的完整实现
        function handleWheel(e, chartType) {
            const chart = charts[chartType];
            if (!chart.chartArea) return;
            
            e.preventDefault();
            
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (mouseX < chart.chartArea.left || mouseX > chart.chartArea.right ||
                mouseY < chart.chartArea.top || mouseY > chart.chartArea.bottom) {
                return;
            }
            
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            const mouseXValue = xScale.getValueForPixel(mouseX);
            const mouseYValue = yScale.getValueForPixel(mouseY);
            
            const zoomIntensity = 0.1;
            const zoomFactor = e.deltaY > 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);
            
            const xMin = xScale.min;
            const xMax = xScale.max;
            const yMin = yScale.min;
            const yMax = yScale.max;
            
            const newXMin = mouseXValue - (mouseXValue - xMin) * zoomFactor;
            const newXMax = mouseXValue + (xMax - mouseXValue) * zoomFactor;
            
            chart.options.scales.x.min = newXMin;
            chart.options.scales.x.max = newXMax;
            
            // 只在整体缩放模式下更新Y轴范
            if (!isXAxisZoomMode) {
                const newYMin = mouseYValue - (mouseYValue - yMin) * zoomFactor;
                const newYMax = mouseYValue + (yMax - mouseYValue) * zoomFactor;
                chart.options.scales.y.min = newYMin;
                chart.options.scales.y.max = newYMax;
            }
            
            chart.update('none');
        }

        // 初始化图表
        initializeCharts();

        // 添加按钮事件监听器
        document.getElementById('dragModeButton').addEventListener('click', () => {
            isSelectMode = !isSelectMode;
            isDragging = false;
            
            let analysisButtonsContainer = document.querySelector('.analysis-container');
            let analysisResult = document.querySelector('.analysis-result');
            
            if (!analysisButtonsContainer || !analysisResult) {
                const containerDiv = document.createElement('div');
                containerDiv.className = 'analysis-container';
                
                analysisButtonsContainer = document.createElement('div');
                analysisButtonsContainer.className = 'analysis-buttons';
                analysisButtonsContainer.innerHTML = `
                    <button id="averageButton" class="analysis-button">平均值</button>
                    <button id="maxButton" class="analysis-button">最大值</button>
                    <button id="minButton" class="analysis-button">最小值</button>
                    <button id="areaButton" class="analysis-button">区域积分</button>
                    <button id="sineFitButton" class="analysis-button">正弦拟合</button>
                    <button id="periodButton" class="analysis-button">周期分析</button>
                `;
                
                analysisResult = document.createElement('div');
                analysisResult.className = 'analysis-result';
                analysisResult.id = 'analysisResult';
                
                containerDiv.appendChild(analysisButtonsContainer);
                containerDiv.appendChild(analysisResult);
                
                document.querySelector('.charts-container').insertBefore(
                    containerDiv, 
                    document.querySelector('.charts-container').firstChild
                );
            }
            
            // 重新绑定事件监听器
            document.getElementById('averageButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handleAverage();
                }
            };
            
            document.getElementById('maxButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handleMax();
                }
            };
            
            document.getElementById('minButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handleMin();
                }
            };
            
            document.getElementById('areaButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handleArea();
                }
            };
            
            document.getElementById('sineFitButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handleSineFit();
                }
            };
            
            document.getElementById('periodButton').onclick = () => {
                if (currentChartContext && selectedData[currentChartContext]) {
                    handlePeriodAnalysis();
                }
            };
            
            analysisButtonsContainer.style.display = isSelectMode ? 'flex' : 'none';
            analysisResult.style.display = isSelectMode ? 'block' : 'none';
            
            if (!isSelectMode) {
                // 退出选择模式时才清除所有选择框和分析结果
                Object.keys(charts).forEach(type => {
                    const chartId = `${type}Chart`;
                    selectionStart[chartId] = null;
                    selectionEnd[chartId] = null;
                    selectionVisible[chartId] = false;
                    selectedData[chartId] = null;
                    charts[type].showIntegralArea = false;
                    
                    // 清除拟曲和图例
                    charts[type].data.datasets[1].data = [];
                    charts[type].data.datasets[1].hidden = true;
                    charts[type].data.datasets[1].display = false;
                    
                    charts[type].update();
                });
                document.getElementById('analysisResult').textContent = '';
            }
            
            dragModeButton.textContent = isSelectMode ? '数据处理模式' : '图像拖动模式';
            dragModeButton.classList.toggle('selecting', isSelectMode);
        });

        document.getElementById('zoomModeButton').addEventListener('click', () => {
            isXAxisZoomMode = !isXAxisZoomMode;
            zoomModeButton.textContent = isXAxisZoomMode ? '横轴缩放' : '整体缩放';
        });

        // 添加数据分析处理函数
        function handleAverage() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            // 清除所有图表的拟合曲线
            Object.values(charts).forEach(chart => {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                chart.update('none');
            });
            
            charts[currentChartContext.replace('Chart', '')].showIntegralArea = false;
            
            const average = selectedData[currentChartContext].reduce((sum, point) => sum + point.y, 0) / 
                           selectedData[currentChartContext].length;
            document.getElementById('analysisResult').textContent = 
                currentChartContext.includes('displacement') ?
                    `平均值: ${average.toFixed(1)} ${getUnit(currentChartContext)}` :
                    `平均值: ${average.toFixed(3)} ${getUnit(currentChartContext)}`;
            charts[currentChartContext.replace('Chart', '')].update();
        }

        function handleMax() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            // 清除所有图表的拟合曲线
            Object.values(charts).forEach(chart => {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                chart.update('none');
            });
            
            const chart = charts[currentChartContext.replace('Chart', '')];
            chart.showIntegralArea = false;
            
            // 找到最大值点
            const maxPoint = selectedData[currentChartContext].reduce((max, point) => 
                point.y > max.y ? point : max, selectedData[currentChartContext][0]);
            
            // 更新第二个数据集来显示最大值点
            chart.data.datasets[1].type = 'scatter';
            chart.data.datasets[1].data = [maxPoint];
            chart.data.datasets[1].hidden = false;
            chart.data.datasets[1].display = true;
            chart.data.datasets[1].pointStyle = 'circle';
            chart.data.datasets[1].pointRadius = 4;
            chart.data.datasets[1].pointBackgroundColor = 'rgba(255, 0, 0, 0.8)';
            chart.data.datasets[1].pointBorderColor = 'rgba(255, 0, 0, 1)';
            chart.data.datasets[1].pointBorderWidth = 1;
            chart.data.datasets[1].showLine = false;
            chart.data.datasets[1].label = undefined;
            
            document.getElementById('analysisResult').textContent = 
                currentChartContext.includes('displacement') ?
                    `最大值: ${maxPoint.y.toFixed(1)} ${getUnit(currentChartContext)} (t = ${maxPoint.x.toFixed(3)} s)` :
                    `最大值: ${maxPoint.y.toFixed(3)} ${getUnit(currentChartContext)} (t = ${maxPoint.x.toFixed(3)} s)`;
            
            chart.update();
        }

        function handleMin() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            // 清除所有图表的拟合曲线
            Object.values(charts).forEach(chart => {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                chart.update('none');
            });
            
            const chart = charts[currentChartContext.replace('Chart', '')];
            chart.showIntegralArea = false;
            
            // 找到最小值点
            const minPoint = selectedData[currentChartContext].reduce((min, point) => 
                point.y < min.y ? point : min, selectedData[currentChartContext][0]);
            
            // 更新第二个数据集来显示最小值点
            chart.data.datasets[1].type = 'scatter';
            chart.data.datasets[1].data = [minPoint];
            chart.data.datasets[1].hidden = false;
            chart.data.datasets[1].display = true;
            chart.data.datasets[1].pointStyle = 'circle';
            chart.data.datasets[1].pointRadius = 4;
            chart.data.datasets[1].pointBackgroundColor = 'rgba(0, 0, 255, 0.8)';
            chart.data.datasets[1].pointBorderColor = 'rgba(0, 0, 255, 1)';
            chart.data.datasets[1].pointBorderWidth = 1;
            chart.data.datasets[1].showLine = false;
            chart.data.datasets[1].label = undefined;
            
            document.getElementById('analysisResult').textContent = 
                currentChartContext.includes('displacement') ?
                    `最小值: ${minPoint.y.toFixed(1)} ${getUnit(currentChartContext)} (t = ${minPoint.x.toFixed(3)} s)` :
                    `最小值: ${minPoint.y.toFixed(3)} ${getUnit(currentChartContext)} (t = ${minPoint.x.toFixed(3)} s)`;
            
            chart.update();
        }

        function handleArea() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            // 清除所有图表的拟合曲线
            Object.values(charts).forEach(chart => {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                chart.update('none');
            });
            
            charts[currentChartContext.replace('Chart', '')].showIntegralArea = true;
            charts[currentChartContext.replace('Chart', '')].update();
            
            const area = calculateArea(selectedData[currentChartContext]);
            
            document.getElementById('analysisResult').textContent = 
                `积分结果: ${area.toFixed(3)} ${getIntegralUnit(currentChartContext)}`;
        }

        // 添加辅助数获取单位
        function getUnit(chartId) {
            switch(chartId) {
                case 'displacementChart': return 'cm';
                case 'velocityChart': return 'm/s';
                case 'accelerationChart': return 'm/s²';
                default: return '';
            }
        }

        function getIntegralUnit(chartId) {
            switch(chartId) {
                case 'displacementChart': return 'cm·s';
                case 'velocityChart': return 'm';
                case 'accelerationChart': return 'm/s';
                default: return '';
            }
        }

        // 添加全局变量
        let isDragging = false;
        let startX, startY;
        let startXMin, startXMax, startYMin, startYMax;

        // 添加计算面积的函数
        function calculateArea(data) {
            if (!data || data.length < 2) return 0;
            
            let area = 0;
            for (let i = 1; i < data.length; i++) {
                const width = data[i].x - data[i-1].x;
                const height = (data[i].y + data[i-1].y) / 2;
                area += width * height;
            }
            
            return area;
        }

        // 修改鼠标右键事件处理
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            if (currentChartContext) {
                // 清除当前图表的选择
                selectionStart[currentChartContext] = null;
                selectionEnd[currentChartContext] = null;
                selectionVisible[currentChartContext] = false;
                selectedData[currentChartContext] = null;
                
                // 清除积分区域
                charts[currentChartContext.replace('Chart', '')].showIntegralArea = false;
                
                // 清除拟合曲线图例
                const chart = charts[currentChartContext.replace('Chart', '')];
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                
                // 更新图表
                chart.update();
                
                // 清除分析结果
                document.querySelector('.analysis-result').textContent = '';
                
                // 更新按钮状态
                updateAnalysisButtons(currentChartContext.replace('Chart', ''));
            }
            
            return false;
        });

        // 添加正弦拟合处理函数
        function handleSineFit() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            // 首先清除所有图表的拟合曲线
            Object.values(charts).forEach(chart => {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].hidden = true;
                chart.data.datasets[1].display = false;
                chart.update('none');
            });
            
            const chart = charts[currentChartContext.replace('Chart', '')];
            const fitResult = sineFit(selectedData[currentChartContext]);
            
            if (!fitResult) {
                document.getElementById('analysisResult').textContent = '数据不足以进行正弦拟合';
                return;
            }
            
            // 更新拟合数据集
            chart.data.datasets[1].type = 'line';
            chart.data.datasets[1].data = fitResult.fittedData;
            chart.data.datasets[1].hidden = false;
            chart.data.datasets[1].display = true;
            chart.data.datasets[1].showLine = true;
            chart.data.datasets[1].label = '正弦拟合';
            chart.data.datasets[1].pointRadius = 0;
            
            // 设置拟合曲线样式
            chart.data.datasets[1].borderWidth = 5;
            chart.data.datasets[1].borderColor = 'rgba(255, 0, 0, 0.8)';
            chart.data.datasets[1].tension = 0.4;
            
            // 显示拟合函数表达式
            const params = fitResult.parameters;
            document.getElementById('analysisResult').textContent = 
                `拟合函数: y = ${params.mean} + ${params.amplitude}·sin(2π·${params.frequency}t + ${params.phase}°)`;
            
            chart.update('none');
        }

        // 修改周期检测函数
        function detectPeriods(data, chartType) {
            if (!data || data.length < 3) return null;
            
            // 根据图表类型选择检测方法
            if (chartType === 'displacement') {
                // 位移图用峰值检测
                let peaks = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i].y > data[i-1].y && data[i].y > data[i+1].y) {
                        peaks.push(data[i]);
                    }
                }
                
                if (peaks.length < 2) return null;
                
                let periods = [];
                for (let i = 1; i < peaks.length; i++) {
                    periods.push(peaks[i].x - peaks[i-1].x);
                }
                
                const averagePeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length;
                
                return {
                    count: periods.length,
                    averagePeriod: averagePeriod
                };
            } else {
                // 速度和加速度图用过零点检测
                const mean = data.reduce((sum, p) => sum + p.y, 0) / data.length;
                let crossings = [];
                
                // 寻找过零点（相对于平均值）
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1].y - mean) * (data[i].y - mean) <= 0) {
                        // 通过线性插值找到更精确的过零点时间
                        const t1 = data[i-1].x;
                        const t2 = data[i].x;
                        const y1 = data[i-1].y - mean;
                        const y2 = data[i].y - mean;
                        const zeroTime = t1 - y1 * (t2 - t1) / (y2 - y1);
                        crossings.push(zeroTime);
                    }
                }
                
                if (crossings.length < 4) return null; // 需要至少两个完整周期
                
                // 计算周期（两个相邻的同向过零点之间的时间差）
                let periods = [];
                for (let i = 2; i < crossings.length; i += 2) {
                    periods.push(crossings[i] - crossings[i-2]);
                }
                
                const averagePeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length;
                
                return {
                    count: periods.length,
                    averagePeriod: averagePeriod
                };
            }
        }

        // 修改周期分析处理函数
        function handlePeriodAnalysis() {
            if (!currentChartContext || !selectedData[currentChartContext]) return;
            
            const chartType = currentChartContext.replace('Chart', '');
            const data = selectedData[currentChartContext];
            const result = detectPeriods(data, chartType);
            
            if (!result) {
                document.getElementById('analysisResult').textContent = '未检测到完整周期';
                return;
            }
            
            document.getElementById('analysisResult').textContent = 
                `检测到 ${result.count} 个完整周期，平均周期: ${result.averagePeriod.toFixed(3)} s`;
        }
    </script>
</body>
</html>
