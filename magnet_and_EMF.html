<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ³•æ‹‰ç¬¬ç”µç£æ„Ÿåº”å®šå¾‹ï¼ˆç£æ„Ÿåº”å¼ºåº¦+æ„Ÿåº”ç”µåŠ¨åŠ¿ï¼‰</title>
    <style>
        /* ä¿ç•™åŸæœ‰æ ·å¼ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 5px;
            background-color: #f0f8ff;
            height: 100%;
            overflow-y: auto;
        }
        
        html {
            height: 100%;
        }

        /* ä¿®æ”¹å›¾è¡¨å®¹å™¨æ ·å¼ */
        #chartContainer {
            height: calc(100vh - 132px);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: margin-top 0.3s ease;
            overflow-y: auto;
        }

        #chartContainer.analysis-mode {
            margin-top: 20px;
        }

        #currentChartContainer, #voltageChartContainer {
            flex: 1;
            position: relative;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* ä¿®æ”¹æ•°å€¼æ˜¾ç¤ºæ ·å¼ï¼Œå¢åŠ å›ºå®šå®½åº¦ */
        .value-display {
            margin-left: 20px;
            font-size: 24px;
            font-weight: bold;
            padding: 10px 20px;
            background-color: #e6f3ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            width: 390px; /* å›ºå®šå®½åº¦ */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #007bff;
        }

        .current-value, .voltage-value {
            margin: 0 10px;
        }

        /* ä¿ç•™å…¶ä»–åŸæœ‰æ ·å¼... */

        /* åˆ†æå·¥å…·æ æ ·å¼ï¼Œæ·»åŠ ç›¸å¯¹å®šä½ä½œä¸ºç»“æœçš„å‚è€ƒç‚¹ */
        .analysis-toolbar {
            display: none;
            gap: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            margin: 5px auto;
            width: 95vw;
            justify-content: flex-start;
            align-items: center;
            height: 40px;
        }

        .analysis-toolbar.show {
            display: flex;
        }

        /* ä¿®æ”¹åˆ†ææŒ‰é’®å®¹å™¨æ ·å¼ */
        .analysis-buttons-container {
            display: flex;
            gap: 10px;
        }

        /* ä¿®æ”¹åˆ†ææŒ‰é’®æ ·å¼ */
        .analysis-button {
            padding: 8px 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
            font-size: 14px;
            transition: all 0.2s;
            width: 160px;
            text-align: center;
            white-space: nowrap;
        }

        .analysis-button.enabled {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            cursor: pointer;
        }

        .analysis-button.enabled:hover {
            background-color: #0056b3;
        }

        /* ä¿®æ”¹åˆ†æç»“æœæ˜¾ç¤ºæ ·å¼ */
        .analysis-results {
            display: none;
            padding: 5px 15px;
            background: #fff;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            text-align: left;
            margin-left: 20px;
        }

        .analysis-results.show {
            display: block;
        }

        .analysis-results .result-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .analysis-results .result-item {
            font-size: 14px;
            padding: 3px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            white-space: nowrap;
        }

        .sync-zoom-toggle {
            position: absolute;
            right: 20px;
            top: -30px;
            padding: 5px 10px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1000;
            font-size: 14px;
        }

        /* ä¿®æ”¹æ ‡é¢˜å®¹å™¨æ ·å¼ */
        .title-container {
            display: flex;
            justify-content: center;
            align-items: baseline;
            margin-bottom: 5px;
        }

        h1 {
            margin: 0;
            color: #007bff;
        }

        .designer {
            font-size: 20px;
            color: #2401e9;
            margin-left: 20px;
            font-family: 'Brush Script MT', cursive;
            font-style: italic;
        }

        /* ä¿®æ”¹æŒ‰é’®å®¹å™¨æ ·å¼ */
        .button-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px auto 0;
            justify-content: center;
            width: 95vw;
            padding: 0;
            flex-shrink: 0;
        }

        /* ä¿®æ”¹æŒ‰é’®æ ·å¼ */
        .green-button, .drag-mode-button, .zoom-mode-button {
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
        }

        .green-button:hover {
            background-color: #218838;
        }

        .green-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        /* å›¾åƒæ‹–åŠ¨æ¨¡å¼æŒ‰é’®é€‰ä¸­çŠ¶æ€ä¸ºè“è‰² */
        .drag-mode-button.selecting {
            background-color: #007bff !important;
        }

        /* ä¿®æ”¹æ•°æ®é€‰æ‹©åŒºåŸŸæ ·å¼ */
        .selection-area {
            position: absolute;
            background-color: rgba(255, 0, 0, 0.1);  /* æ·¡çº¢è‰² */
            border: 1px solid rgba(255, 0, 0, 0.3);
            pointer-events: none;
        }

        /* åŒæ­¥æŒ‰é’®æ ·å¼ */
        .sync-charts-button {
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px 0;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sync-charts-button.active {
            background-color: #007bff;
        }

        .sync-charts-button:hover {
            background-color: #218838;
        }

        .sync-charts-button.active:hover {
            background-color: #0056b3;
        }
        
        /* æ·»åŠ Yè½´åŒæ­¥é€‰é¡¹æ ·å¼ */
        .sync-y-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-size: 14px;
        }
        
        .sync-y-checkbox {
            margin-right: 5px;
        }
    </style>
    <!-- ä¿ç•™åŸæœ‰å¤´éƒ¨å†…å®¹... -->
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js" as="script">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js" as="script">
    <script>
        // ç¦ç”¨å³é”®èœå•
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // ç¦ç”¨F12ã€Ctrl+Shift+Iã€Ctrl+U
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && e.keyCode == 73) || (e.ctrlKey && e.keyCode == 85)) {
                return false;
            }
        };
        
        // å®šä¹‰è“ç‰™è®¾å¤‡é…ç½®ï¼Œå®šä¹‰çš„50ä¸ªè®¾å¤‡å¯ä»¥è¿æ¥
        const BLUETOOTH_DEVICES = Array.from({ length: 50 }, (_, i) => ({
            name: `yykdislab${i + 1}`,
            serviceUUID: `cddf1001-30f7-4671-8b43-5e40ba53${(i + 1).toString().padStart(4, '0')}`,
            characteristicUUID: `cddf1002-30f7-4671-8b43-5e40ba53${(i + 1).toString().padStart(4, '0')}`
        }));
    </script>
</head>
<body>
    <div class="title-container">
        <h1>æ³•æ‹‰ç¬¬ç”µç£æ„Ÿåº”å®šå¾‹ï¼ˆç£æ„Ÿåº”å¼ºåº¦+æ„Ÿåº”ç”µåŠ¨åŠ¿ï¼‰</h1>
        <span class="designer">æ¨ç‡•ç¨è€å¸ˆè®¾è®¡</span>
    </div>
    <div class="button-container">
        <div class="button-group">
            <button id="connectButton" class="green-button">è¿æ¥è®¾å¤‡</button>
            <button id="drawAndDataButton" class="green-button">é‡‡é›†æ•°æ®</button>
            <button id="clearDataButton" class="green-button">æ¸…é™¤æ•°æ®</button>
            <button id="exportDataButton" class="green-button">ä¿å­˜æ•°æ®</button>
            <button id="autoScaleButton" class="green-button">è‡ªåŠ¨ç¼©æ”¾</button>
            <button id="zoomModeButton" class="zoom-mode-button">æ•´ä½“ç¼©æ”¾</button>
            <button id="dragModeButton" class="drag-mode-button">å›¾åƒæ‹–åŠ¨æ¨¡å¼</button>
            <div class="sync-controls" style="display: flex; align-items: center;">
                <button id="syncChartsButton" class="sync-charts-button">
                    <span id="syncIcon">ğŸ”„</span> å›¾è¡¨è”åŠ¨: å…³é—­
                </button>
                <div class="sync-y-container">
                    <input type="checkbox" id="syncYAxis" class="sync-y-checkbox" disabled>
                    <label for="syncYAxis">åŒæ­¥Yè½´ç¼©æ”¾</label>
                </div>
            </div>
        </div>
        <div id="valueDisplayButton" class="value-display">
            <div class="current-value">B: 0.00 mT</div>
            <div class="voltage-value">EMF: 0.0 mV</div>
        </div>
    </div>
            <div class="analysis-toolbar">
            <div class="analysis-buttons-container">
                <button class="analysis-button" data-analysis="combined">æ•°æ®åˆ†æ(æ‹Ÿåˆ+ç»Ÿè®¡)</button>
                <button class="analysis-button" id="extractDataButton">æå–æ•°æ®</button>
            </div>
            <div class="analysis-results"></div>
        </div>
    <div id="chartContainer">
        <div id="currentChartContainer">
            <canvas id="currentChart"></canvas>
        </div>
        <div id="voltageChartContainer">
            <canvas id="voltageChart"></canvas>
        </div>
    </div>
    
    <!-- æ·»åŠ è¡¨æ ¼å’Œæ–°å›¾è¡¨åŒºåŸŸ -->
    <div style="display: flex; gap: 20px; padding: 20px; background-color: #f8f9fa; margin: 10px; border-radius: 5px;">
        <!-- æ•°æ®è¡¨æ ¼ -->
        <div style="flex: 1;">
            <h4 style="margin-bottom: 10px; color: #007bff;">å®éªŒæ•°æ®è®°å½•è¡¨</h4>
            <table id="dataTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 5px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <tr>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #e3f2fd; color: #333;">Î”B/Î”tï¼ˆmT/sï¼‰</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white;"></th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white;"></th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white;"></th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white;"></th>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: #e3f2fd; font-weight: bold;">E/mV</td>
                    <td id="cell-1-1" style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white; font-weight: bold;"></td>
                    <td id="cell-1-2" style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white; font-weight: bold;"></td>
                    <td id="cell-1-3" style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white; font-weight: bold;"></td>
                    <td id="cell-1-4" style="border: 1px solid #ddd; padding: 8px; text-align: center; background-color: white; font-weight: bold;"></td>
                </tr>
            </table>
        </div>
        
        <!-- æ–°çš„æ•£ç‚¹å›¾ -->
        <div style="flex: 1; position: relative;">
            <h4 style="margin-bottom: 10px; color: #007bff;">Î”B/Î”t vs EMFå…³ç³»å›¾</h4>
            <div style="position: relative; background: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 5px;">
                <div style="position: absolute; top: 5px; right: 5px; z-index: 100; display: flex; flex-direction: column; gap: 3px;">
                    <button id="fitToggleButton" style="padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">çº¿æ€§æ‹Ÿåˆ</button>
                    <button id="deleteDataButton" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">åˆ é™¤æ•°æ®</button>
                </div>
                <canvas id="scatterChart" width="400" height="300" style="display: block; margin: 0 auto;"></canvas>
                <div id="fitEquation" style="margin-top: 5px; font-size: 16px; color: #28a745; font-weight: bold; text-align: center; display: none;"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <script>
        let currentChart, voltageChart, scatterChart;
        let bluetoothDevice;
        let characteristic;
        let receivingData = false;
        let dataBuffer = {
            current: [],
            voltage: []
        };
        let startTime = null;
        let isDrawingChart = false;
        let animationFrameId = null;
        let startX, startY;
        let startXMin, startXMax, startYMin, startYMax;
        
        // æ·»åŠ å›¾è¡¨è”åŠ¨æ ‡å¿—
        let syncCharts = false;
        
        // ç¼©æ”¾æ¨¡å¼å˜é‡
        let isXAxisZoomMode = false;

        // æ·»åŠ å…¨å±€å˜é‡
        let syncYAxis = false;

        // åˆå§‹åŒ–ä¸¤ä¸ªå›¾è¡¨
        function initializeCharts() {
            // é¦–å…ˆæ³¨å†Œæ’ä»¶
            const selectionPlugin = {
                id: 'selection',
                beforeDraw: (chart) => {
                    if (selectionStart && selectionEnd) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        
                        // è·å–é€‰æ‹©æ¡†çš„åƒç´ åæ ‡
                        const startX = chart.scales.x.getPixelForValue(selectionStart.x);
                        const endX = chart.scales.x.getPixelForValue(selectionEnd.x);
                        
                        // ç»˜åˆ¶é€‰æ‹©æ¡†ï¼Œæ ¹æ®ä¸åŒå›¾è¡¨ä½¿ç”¨ä¸åŒé¢œè‰²
                        ctx.save();
                        
                        // ç£åœºå›¾è¡¨ç”¨æ·¡è“è‰²ï¼Œç”µå‹å›¾è¡¨ç”¨æ·¡çº¢è‰²
                        if (chart === currentChart) {
                            ctx.fillStyle = 'rgba(135, 206, 235, 0.2)'; // ç£åœºï¼šæ·¡è“è‰²å¡«å……
                            ctx.strokeStyle = 'rgba(135, 206, 235, 0.5)'; // ç£åœºï¼šæ·¡è“è‰²è¾¹æ¡†
                        } else {
                            ctx.fillStyle = 'rgba(255, 182, 193, 0.2)'; // ç”µå‹ï¼šæ·¡çº¢è‰²å¡«å……
                            ctx.strokeStyle = 'rgba(255, 182, 193, 0.5)'; // ç”µå‹ï¼šæ·¡çº¢è‰²è¾¹æ¡†
                        }
                        
                        ctx.lineWidth = 1;
                        
                        // ç»˜åˆ¶å¡«å……åŒºåŸŸ
                        ctx.fillRect(
                            Math.min(startX, endX),
                            chartArea.top,
                            Math.abs(endX - startX),
                            chartArea.bottom - chartArea.top
                        );
                        
                        // ç»˜åˆ¶è¾¹æ¡†
                        ctx.strokeRect(
                            Math.min(startX, endX),
                            chartArea.top,
                            Math.abs(endX - startX),
                            chartArea.bottom - chartArea.top
                        );
                        
                        ctx.restore();
                    }
                }
            };



            // æ³¨å†Œæ’ä»¶
            Chart.register(selectionPlugin);

            // ä¿®æ”¹å›¾è¡¨é…ç½®ï¼Œæ·»åŠ æ’ä»¶é…ç½®
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'æ—¶é—´ (s)'
                        }
                    }
                }
            };

            // ç¬¬ä¸€ä¸ªå›¾è¡¨é…ç½®ï¼ˆç£æ„Ÿåº”å¼ºåº¦ï¼‰
            currentChart = new Chart(document.getElementById('currentChart').getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'ç£æ„Ÿåº”å¼ºåº¦',
                        data: [],
                        borderColor: '#007bff',
                        tension: 0.1,
                        pointRadius: 2,
                        pointBackgroundColor: '#007bff',
                        showLine: true,
                        borderWidth: 2,
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            title: {
                                display: true,
                                text: 'ç£æ„Ÿåº”å¼ºåº¦ (mT)'
                            }
                        }
                    }
                }
            });

            // ç¬¬äºŒä¸ªå›¾è¡¨é…ç½®ï¼ˆç”µå‹ï¼‰
            voltageChart = new Chart(document.getElementById('voltageChart').getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'æ„Ÿåº”ç”µåŠ¨åŠ¿',
                        data: [],
                        borderColor: '#dc3545',
                        tension: 0.1,
                        pointRadius: 2,
                        pointBackgroundColor: '#dc3545',
                        showLine: true,
                        borderWidth: 2,
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            title: {
                                display: true,
                                text: 'æ„Ÿåº”ç”µåŠ¨åŠ¿ (mV)'
                            }
                        }
                    }
                }
            });
            
            // åˆå§‹åŒ–æ•£ç‚¹å›¾
            initializeScatterChart();
        }

        // åˆå§‹åŒ–æ•£ç‚¹å›¾
        function initializeScatterChart() {
            const scatterCtx = document.getElementById('scatterChart').getContext('2d');
            scatterChart = new Chart(scatterCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'å®éªŒæ•°æ®',
                        data: [],
                        backgroundColor: '#dc3545',
                        borderColor: '#dc3545',
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        showLine: false
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 8
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'ç£æ„Ÿåº”å¼ºåº¦å˜åŒ–ç‡ (mT/s)',
                                padding: 8
                            },
                            beginAtZero: true,
                            grid: {
                                display: true,
                                drawBorder: true
                            },
                            ticks: {
                                padding: 5
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'æ„Ÿåº”ç”µåŠ¨åŠ¿ (mV)',
                                padding: 8
                            },
                            beginAtZero: true,
                            grid: {
                                display: true,
                                drawBorder: true
                            },
                            ticks: {
                                padding: 5
                            }
                        }
                    }
                }
            });
        }

        // ä¿®æ”¹æ•°æ®å¤„ç†å‡½æ•°
        function handleCharacteristicValueChanged(event) {
            if (!receivingData) return;

            try {
                const value = event.target.value;
                const dataView = new DataView(value.buffer);
                const currentValue = dataView.getFloat32(0, true);
                const voltageValue = dataView.getFloat32(4, true);
                const timeValue = dataView.getFloat32(8, true);  // è¯»å–ESP32å‘é€çš„æ—¶é—´æ•°æ®
                
                // æ›´æ–°æ˜¾ç¤ºå€¼
                updateValueDisplay(currentValue, voltageValue);

                // å¦‚æœæ­£åœ¨ç»˜å›¾ï¼Œæ·»åŠ æ•°æ®ç‚¹
                if (isDrawingChart) {
                    // æ·»åŠ æ–°æ•°æ®ç‚¹ï¼Œä½¿ç”¨ESP32å‘é€çš„æ—¶é—´æ•°æ®
                    dataBuffer.current.push({ x: timeValue, y: currentValue });
                    dataBuffer.voltage.push({ x: timeValue, y: voltageValue });

                    // å¦‚æœæ•°æ®ç‚¹è¶…è¿‡3000ä¸ªï¼Œåˆ é™¤æœ€æ—©çš„æ•°æ®ç‚¹
                    if (dataBuffer.current.length > 3000) {
                        dataBuffer.current.shift();
                    }
                    if (dataBuffer.voltage.length > 3000) {
                        dataBuffer.voltage.shift();
                    }

                    if (!animationFrameId) {
                        animationFrameId = requestAnimationFrame(updateChartsAndDisplay);
                    }
                }
            } catch (error) {
                console.error('æ•°æ®å¤„ç†é”™è¯¯:', error);
            }
        }

        // æ›´æ–°æ˜¾ç¤ºå€¼ï¼Œè°ƒæ•´ç²¾åº¦
        function updateValueDisplay(current, voltage) {
            const valueDisplay = document.getElementById('valueDisplayButton');
            valueDisplay.innerHTML = `
                <div class="current-value">B: ${current.toFixed(2)} mT</div>
                <div class="voltage-value">EMF: ${voltage.toFixed(1)} mV</div>
            `;
        }

        // ä¿®æ”¹å›¾è¡¨æ›´æ–°å‡½æ•°
        function updateChartsAndDisplay() {
            if (dataBuffer.current.length > 0 && dataBuffer.voltage.length > 0) {
                currentChart.data.datasets[0].data = [...dataBuffer.current];
                voltageChart.data.datasets[0].data = [...dataBuffer.voltage];

                // æ›´æ–°åæ ‡è½´èŒƒå›´
                const timeValues = dataBuffer.current.map(point => point.x);
                const maxTime = Math.max(...timeValues);

                // è·å–Yè½´æ•°æ®èŒƒå›´
                const currentYValues = dataBuffer.current.map(point => point.y);
                const voltageYValues = dataBuffer.voltage.map(point => point.y);
                
                // è®¡ç®—å½“å‰å¯è§çª—å£çš„æ•°æ® (æœ€è¿‘10ç§’)
                const visibleTimeStart = Math.max(0, maxTime - 10);
                const visibleCurrentData = dataBuffer.current.filter(point => point.x >= visibleTimeStart && point.x <= maxTime + 2);
                const visibleVoltageData = dataBuffer.voltage.filter(point => point.x >= visibleTimeStart && point.x <= maxTime + 2);
                
                // è·å–å¯è§æ•°æ®çš„Yè½´èŒƒå›´
                const currentYMin = visibleCurrentData.length > 0 ? Math.min(...visibleCurrentData.map(p => p.y)) : Math.min(...currentYValues);
                const currentYMax = visibleCurrentData.length > 0 ? Math.max(...visibleCurrentData.map(p => p.y)) : Math.max(...currentYValues);
                const voltageYMin = visibleVoltageData.length > 0 ? Math.min(...visibleVoltageData.map(p => p.y)) : Math.min(...voltageYValues);
                const voltageYMax = visibleVoltageData.length > 0 ? Math.max(...visibleVoltageData.map(p => p.y)) : Math.max(...voltageYValues);
                
                // æ·»åŠ ä¸€äº›è¾¹è·
                const currentYPadding = Math.max(0.2, (currentYMax - currentYMin) * 0.1);
                const voltageYPadding = Math.max(0.2, (voltageYMax - voltageYMin) * 0.1);

                if (!isDragging) {
                    // æ›´æ–°Xè½´èŒƒå›´
                    currentChart.options.scales.x.min = Math.max(0, maxTime - 10);
                    currentChart.options.scales.x.max = maxTime + 2;
                    voltageChart.options.scales.x.min = Math.max(0, maxTime - 10);
                    voltageChart.options.scales.x.max = maxTime + 2;
                    
                    // è‡ªåŠ¨æ›´æ–°Yè½´èŒƒå›´
                    currentChart.options.scales.y.min = currentYMin - currentYPadding;
                    currentChart.options.scales.y.max = currentYMax + currentYPadding;
                    voltageChart.options.scales.y.min = voltageYMin - voltageYPadding;
                    voltageChart.options.scales.y.max = voltageYMax + voltageYPadding;
                }

                currentChart.update('none');
                voltageChart.update('none');
            }

            if (isDrawingChart) {
                animationFrameId = requestAnimationFrame(updateChartsAndDisplay);
            } else {
                animationFrameId = null;
            }
        }

        // åœ¨æ–‡æ¡£åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMå®Œå…¨åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
            
            // åˆå§‹åŒ–å›¾è¡¨
            initializeCharts();
            console.log('å›¾è¡¨åˆå§‹åŒ–å®Œæˆ');
            
            // æ·»åŠ å›¾è¡¨äº‹ä»¶ç›‘å¬å™¨
            addChartEventListeners();
            console.log('å›¾è¡¨äº‹ä»¶ç›‘å¬å™¨æ·»åŠ å®Œæˆ');
            
            // è®¾ç½®è¿æ¥æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            const connectButton = document.getElementById('connectButton');
            console.log('è®¾ç½®è¿æ¥æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨');
            connectButton.addEventListener('click', function() {
                console.log('è¿æ¥æŒ‰é’®è¢«ç‚¹å‡»');
                connectToDevice();
            });
            
            // æ·»åŠ è‡ªåŠ¨ç¼©æ”¾æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            const autoScaleButton = document.getElementById('autoScaleButton');
            autoScaleButton.addEventListener('click', function() {
                console.log('è‡ªåŠ¨ç¼©æ”¾æŒ‰é’®è¢«ç‚¹å‡»');
                autoScaleCharts();
            });
            
            // æ·»åŠ ç¼©æ”¾æ¨¡å¼åˆ‡æ¢æŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨
            const zoomModeButton = document.getElementById('zoomModeButton');
            zoomModeButton.addEventListener('click', function() {
                isXAxisZoomMode = !isXAxisZoomMode;
                zoomModeButton.textContent = isXAxisZoomMode ? 'æ¨ªè½´ç¼©æ”¾' : 'æ•´ä½“ç¼©æ”¾';
                console.log(`ç¼©æ”¾æ¨¡å¼åˆ‡æ¢ä¸º: ${isXAxisZoomMode ? 'æ¨ªè½´ç¼©æ”¾' : 'æ•´ä½“ç¼©æ”¾'}`);
            });
            
            // è®¾ç½®è”åŠ¨æŒ‰é’®å’ŒYè½´åŒæ­¥é€‰é¡¹
            const syncChartsButton = document.getElementById('syncChartsButton');
            const syncYAxisCheckbox = document.getElementById('syncYAxis');
            
            syncChartsButton.addEventListener('click', function() {
                syncCharts = !syncCharts;
                this.textContent = `ğŸ”„ å›¾è¡¨è”åŠ¨: ${syncCharts ? 'å¼€å¯' : 'å…³é—­'}`;
                this.classList.toggle('active', syncCharts);
                
                // æ›´æ–°Yè½´åŒæ­¥é€‰é¡¹çš„çŠ¶æ€
                syncYAxisCheckbox.disabled = !syncCharts;
                if (!syncCharts) {
                    syncYAxisCheckbox.checked = false;
                    syncYAxis = false;
                }
            });
            
            syncYAxisCheckbox.addEventListener('change', function() {
                syncYAxis = this.checked;
            });
            
            // æ·»åŠ æ–°æŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨
            setupNewButtonListeners();
            
            console.log('åˆå§‹åŒ–å®Œæˆ');
        });
        
                    // è®¾ç½®æ–°æŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨
        function setupNewButtonListeners() {
            // æå–æ•°æ®æŒ‰é’®
            const extractButton = document.getElementById('extractDataButton');
            extractButton.disabled = true; // åˆå§‹çŠ¶æ€ç¦ç”¨
            extractButton.classList.remove('enabled');
            extractButton.addEventListener('click', function() {
                if (lastAnalysisResult && lastAnalysisResult.slope && lastAnalysisResult.voltage) {
                    if (currentColumn <= 4) {
                        // åœ¨è¡¨æ ¼ä¸­å¡«å…¥æ•°æ®
                        const slopeCell = document.querySelector(`#dataTable tr:first-child th:nth-child(${currentColumn + 1})`);
                        const voltageCell = document.getElementById(`cell-1-${currentColumn}`);
                        
                        slopeCell.textContent = lastAnalysisResult.slope.toFixed(4);
                        voltageCell.textContent = lastAnalysisResult.voltage.toFixed(1);
                        
                        // åœ¨æ•£ç‚¹å›¾ä¸­æ·»åŠ æ•°æ®ç‚¹
                        extractedData.push({
                            x: lastAnalysisResult.slope,
                            y: lastAnalysisResult.voltage
                        });
                        
                        updateScatterChart();
                        currentColumn++;
                        
                        if (currentColumn > 4) {
                            extractButton.textContent = 'è¡¨æ ¼å·²æ»¡';
                            extractButton.disabled = true;
                        }
                    }
                } else {
                    alert('è¯·å…ˆè¿›è¡Œæ•°æ®åˆ†æ');
                }
            });
            
            // åˆ é™¤è¡¨æ ¼æ•°æ®æŒ‰é’®
            const deleteButton = document.getElementById('deleteDataButton');
            deleteButton.addEventListener('click', function() {
                if (currentColumn > 1) {
                    currentColumn--;
                    
                    // æ¸…ç©ºè¡¨æ ¼å•å…ƒæ ¼
                    const slopeCell = document.querySelector(`#dataTable tr:first-child th:nth-child(${currentColumn + 1})`);
                    const voltageCell = document.getElementById(`cell-1-${currentColumn}`);
                    
                    slopeCell.textContent = '';
                    voltageCell.textContent = '';
                    
                    // ä»æ•£ç‚¹å›¾ä¸­åˆ é™¤æœ€åä¸€ä¸ªæ•°æ®ç‚¹
                    if (extractedData.length > 0) {
                        extractedData.pop();
                        updateScatterChart();
                    }
                    
                    // é‡æ–°å¯ç”¨æå–æŒ‰é’®
                    const extractButton = document.getElementById('extractDataButton');
                    extractButton.textContent = 'æå–æ•°æ®';
                    extractButton.disabled = false;
                }
            });
            
            // æ‹Ÿåˆæ§åˆ¶æŒ‰é’®
            const fitToggleButton = document.getElementById('fitToggleButton');
            fitToggleButton.addEventListener('click', function() {
                showFitLine = !showFitLine;
                this.textContent = showFitLine ? 'å–æ¶ˆæ‹Ÿåˆ' : 'çº¿æ€§æ‹Ÿåˆ';
                this.style.backgroundColor = showFitLine ? '#dc3545' : '#28a745';
                updateScatterChart();
            });
        }
        
        // æ›´æ–°æ•£ç‚¹å›¾
        function updateScatterChart() {
            // æ›´æ–°æ•°æ®ç‚¹
            scatterChart.data.datasets[0].data = [...extractedData];
            
            const fitEquationDiv = document.getElementById('fitEquation');
            
            // å¤„ç†æ‹Ÿåˆçº¿
            if (showFitLine && extractedData.length >= 2) {
                // è®¡ç®—çº¿æ€§æ‹Ÿåˆ
                const fitResult = calculateLinearFitForScatter(extractedData);
                
                // æ·»åŠ æˆ–æ›´æ–°æ‹Ÿåˆçº¿æ•°æ®é›†
                if (scatterChart.data.datasets.length === 1) {
                    scatterChart.data.datasets.push({
                        label: 'çº¿æ€§æ‹Ÿåˆ',
                        data: fitResult.fittedData,
                        borderColor: '#28a745',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        showLine: true,
                        tension: 0
                    });
                } else {
                    scatterChart.data.datasets[1].data = fitResult.fittedData;
                }
                
                // æ˜¾ç¤ºæ‹Ÿåˆæ–¹ç¨‹
                fitEquationDiv.style.display = 'block';
                fitEquationDiv.textContent = `æ‹Ÿåˆæ–¹ç¨‹: E = ${fitResult.slope.toFixed(4)} Ã— (Î”B/Î”t) + ${fitResult.intercept.toFixed(2)}`;
            } else {
                // ç§»é™¤æ‹Ÿåˆçº¿
                if (scatterChart.data.datasets.length > 1) {
                    scatterChart.data.datasets.pop();
                }
                
                // éšè—æ‹Ÿåˆæ–¹ç¨‹
                fitEquationDiv.style.display = 'none';
            }
            
            scatterChart.update();
        }
        
        // ä¸ºæ•£ç‚¹å›¾è®¡ç®—çº¿æ€§æ‹Ÿåˆ
        function calculateLinearFitForScatter(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            data.forEach(point => {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumXX += point.x * point.x;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // ç”Ÿæˆæ‹Ÿåˆçº¿æ•°æ®ï¼Œç¡®ä¿çº¿æ¡æ¥è§¦åˆ°åæ ‡è½´
            const xMin = 0; // ä»åŸç‚¹å¼€å§‹
            const xMax = Math.max(...data.map(p => p.x)) * 1.2; // ç¨å¾®å»¶é•¿
            
            const fittedData = [
                { x: xMin, y: slope * xMin + intercept },
                { x: xMax, y: slope * xMax + intercept }
            ];
            
            return { slope, intercept, fittedData };
        }

        // ä¿®æ”¹è¿æ¥å‡½æ•°
        async function connectToDevice() {
            try {
                if (!navigator.bluetooth) {
                    alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè“ç‰™åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨Chromeæµè§ˆå™¨');
                    return;
                }

                if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                    await disconnectFromDevice();
                }

                // æ„å»ºè®¾å¤‡è¿‡æ»¤å™¨å’ŒæœåŠ¡æ•°ç»„
                const filters = BLUETOOTH_DEVICES.map(device => ({ name: device.name }));
                const optionalServices = BLUETOOTH_DEVICES.map(device => device.serviceUUID);

                console.log('å¼€å§‹è¯·æ±‚è“ç‰™è®¾å¤‡...'); // æ·»åŠ è°ƒè¯•æ—¥å¿—
                console.log('å¯ç”¨è®¾å¤‡åç§°:', filters.map(f => f.name)); // æ˜¾ç¤ºå¯ç”¨è®¾å¤‡åç§°

                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: filters,
                    optionalServices: optionalServices
                });

                console.log('é€‰æ‹©çš„è®¾å¤‡:', bluetoothDevice.name); // æ·»åŠ è°ƒè¯•æ—¥å¿—

                const server = await bluetoothDevice.gatt.connect();
                console.log('GATTæœåŠ¡å™¨å·²è¿æ¥'); // æ·»åŠ è°ƒè¯•æ—¥å¿—

                // æ ¹æ®è¿æ¥çš„è®¾å¤‡åç§°æ‰¾åˆ°å¯¹åº”çš„é…ç½®
                const deviceConfig = BLUETOOTH_DEVICES.find(device => device.name === bluetoothDevice.name);
                if (!deviceConfig) {
                    throw new Error('æœªæ‰¾åˆ°åŒ¹é…çš„è®¾å¤‡é…ç½®');
                }

                console.log('ä½¿ç”¨è®¾å¤‡é…ç½®:', deviceConfig); // æ·»åŠ è°ƒè¯•æ—¥å¿—

                const service = await server.getPrimaryService(deviceConfig.serviceUUID);
                characteristic = await service.getCharacteristic(deviceConfig.characteristicUUID);

                console.log('å¯åŠ¨é€šçŸ¥...');
                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);

                console.log('è¿æ¥æˆåŠŸ');
                connectButton.textContent = 'æ–­å¼€è®¾å¤‡';
                connectButton.removeEventListener('click', connectToDevice);
                connectButton.addEventListener('click', disconnectFromDevice);

                drawAndDataButton.disabled = false;
                drawAndDataButton.classList.add('enabled');

                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

            } catch (error) {
                console.error('è“ç‰™è¿æ¥é”™è¯¯:', error);
                alert('è¿æ¥å¤±è´¥: ' + error.message);
                await disconnectFromDevice();
            }
        }

        // ä¿®æ”¹æ–­å¼€è¿æ¥å‡½æ•°
        async function disconnectFromDevice() {
            try {
                if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                    if (isDrawingChart) {
                        isDrawingChart = false;
                        receivingData = false;
                        drawAndDataButton.textContent = 'é‡‡é›†æ•°æ®';
                        if (characteristic) {
                            try {
                                await characteristic.stopNotifications();
                            } catch (error) {
                                console.error('åœæ­¢é€šçŸ¥å¤±è´¥:', error);
                            }
                        }
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                            animationFrameId = null;
                        }
                    }
                    console.log('æ–­å¼€è¿æ¥...');
                    bluetoothDevice.gatt.disconnect();
                }
            } catch (error) {
                console.error('æ–­å¼€è¿æ¥é”™è¯¯:', error);
            } finally {
                onDisconnected();
            }
        }

        // ä¿®æ”¹æ–­è¿æ¥å¤„ç†å‡½æ•°
        function onDisconnected() {
            console.log('è®¾å¤‡å·²æ–­å¼€è¿æ¥');
            connectButton.textContent = 'è¿æ¥è®¾å¤‡';
            connectButton.removeEventListener('click', disconnectFromDevice);
            connectButton.addEventListener('click', connectToDevice);
            drawAndDataButton.disabled = true;
            drawAndDataButton.classList.remove('enabled');
            bluetoothDevice = null;
            characteristic = null;
        }

        // æ•°æ®é‡‡æ§åˆ¶
        const drawAndDataButton = document.getElementById('drawAndDataButton');
        drawAndDataButton.addEventListener('click', () => {
            if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
                console.error('è¯·å…ˆè¿æ¥è®¾å¤‡');
                return;
            }

            isDrawingChart = !isDrawingChart;
            receivingData = isDrawingChart;

            if (isDrawingChart) {
                // ç§»é™¤startTimeçš„åˆå§‹åŒ–ï¼Œå› ä¸ºä¸å†ä½¿ç”¨ç³»ç»Ÿæ—¶é—´
                drawAndDataButton.textContent = 'åœæ­¢é‡‡é›†';
                
                if (characteristic) {
                    characteristic.startNotifications()
                        .then(() => {
                            console.log('æ•°æ®é€šçŸ¥å·²å¯ç”¨');
                            if (!animationFrameId) {
                                animationFrameId = requestAnimationFrame(updateChartsAndDisplay);
                            }
                        })
                        .catch(error => {
                            console.error('å¯ç”¨é€šçŸ¥å¤±è´¥:', error);
                            isDrawingChart = false;
                            receivingData = false;
                            drawAndDataButton.textContent = 'é‡‡é›†æ•°æ®';
                        });
                }
            } else {
                drawAndDataButton.textContent = 'é‡‡é›†æ•°æ®';
                if (characteristic) {
                    characteristic.stopNotifications()
                        .catch(error => console.error('åœæ­¢é€šçŸ¥å¤±è´¥:', error));
                }
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        });

        // æ¸…é™¤æ•°æ®
        document.getElementById('clearDataButton').addEventListener('click', () => {
            dataBuffer.current = [];
            dataBuffer.voltage = [];
            startTime = null;
            currentChart.data.datasets[0].data = [];
            voltageChart.data.datasets[0].data = [];
            currentChart.update();
            voltageChart.update();
        });

        // å¯¼å‡ºæ•°æ®
        document.getElementById('exportDataButton').addEventListener('click', () => {
            const worksheet = XLSX.utils.aoa_to_sheet([
                ['æ—¶é—´ (s)', 'ç£æ„Ÿåº”å¼ºåº¦ (mT)', 'æ„Ÿåº”ç”µåŠ¨åŠ¿ (mV)']
            ]);

            const data = dataBuffer.current.map((point, index) => [
                point.x,
                point.y,
                dataBuffer.voltage[index].y
            ]);

            XLSX.utils.sheet_add_aoa(worksheet, data, {origin: -1});
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'å®éªŒæ•°æ®');
            XLSX.writeFile(workbook, 'ç”µå®¹å™¨å……æ”¾ç”µæ•°æ®.xlsx');
        });

        // å›¾è¡¨äº¤äº’æ§åˆ¶
        let isDragging = false;
        let isSelectMode = false;
        let selectionStart = null;
        let selectionEnd = null;
        let selectedChart = null;

        // æ‹–åŠ¨æ¨¡å¼åˆ‡æ¢
        document.getElementById('dragModeButton').addEventListener('click', () => {
            isSelectMode = !isSelectMode;
            isDragging = false;
            const dragModeButton = document.getElementById('dragModeButton');
            const analysisToolbar = document.querySelector('.analysis-toolbar');
            const analysisResults = document.querySelector('.analysis-results');
            const chartContainer = document.getElementById('chartContainer');
            
            dragModeButton.textContent = isSelectMode ? 'æ•°æ®åˆ†ææ¨¡å¼' : 'å›¾åƒæ‹–åŠ¨æ¨¡å¼';
            dragModeButton.classList.toggle('selecting', isSelectMode);
            
            // æ˜¾ç¤º/éšè—åˆ†æå·¥å…·æ 
            analysisToolbar.classList.toggle('show', isSelectMode);
            // è°ƒæ•´å›¾è¡¨å®¹å™¨è¾¹è·
            chartContainer.classList.toggle('analysis-mode', isSelectMode);

            // å¦‚æœåˆ‡æ¢åˆ°å›¾åƒæ‹–åŠ¨æ¨¡å¼ï¼Œéšè—åˆ†æç»“æœå’Œæ‰€æœ‰æ‹Ÿåˆæ›²çº¿
            if (!isSelectMode) {
                analysisResults.classList.remove('show');
                analysisResults.innerHTML = '';
                // æ¸…é™¤ä¸¤ä¸ªå›¾è¡¨çš„æ‹Ÿåˆæ›²çº¿
                if (currentChart.data.datasets.length > 1) {
                    currentChart.data.datasets.pop();
                    currentChart.update();
                }
                if (voltageChart.data.datasets.length > 1) {
                    voltageChart.data.datasets.pop();
                    voltageChart.update();
                }
                // æ¸…é™¤é€‰æ‹©åŒºåŸŸ
                clearSelection(selectedChart);
            }
        });

        // æ·»åŠ é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
        function addChartEventListeners() {
            const currentCanvas = document.getElementById('currentChart');
            const voltageCanvas = document.getElementById('voltageChart');

            [currentCanvas, voltageCanvas].forEach(canvas => {
                canvas.addEventListener('mousedown', startDragging);
                canvas.addEventListener('mousemove', drag);
                canvas.addEventListener('mouseup', stopDragging);
                canvas.addEventListener('mouseleave', stopDragging);
                canvas.addEventListener('wheel', handleWheel);
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    clearSelection(canvas === currentCanvas ? currentChart : voltageChart);
                });
            });
        }

        // å¤„ç†é¼ æ ‡æ»šè½®ç¼©æ”¾
        function handleWheel(e) {
            e.preventDefault();
            const chart = e.target === document.getElementById('currentChart') ? currentChart : voltageChart;
            const otherChart = chart === currentChart ? voltageChart : currentChart;
            
            if (!chart.chartArea) return;

            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (mouseX < chart.chartArea.left || mouseX > chart.chartArea.right ||
                mouseY < chart.chartArea.top || mouseY > chart.chartArea.bottom) {
                return;
            }

            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            const mouseXValue = xScale.getValueForPixel(mouseX);
            const mouseYValue = yScale.getValueForPixel(mouseY);

            const zoomIntensity = 0.1;
            const zoomFactor = e.deltaY > 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);

            const xMin = xScale.min;
            const xMax = xScale.max;
            const newXMin = mouseXValue - (mouseXValue - xMin) * zoomFactor;
            const newXMax = mouseXValue + (xMax - mouseXValue) * zoomFactor;

            chart.options.scales.x.min = newXMin;
            chart.options.scales.x.max = newXMax;

            // åŒæ­¥å¦ä¸€ä¸ªå›¾è¡¨çš„Xè½´èŒƒå›´ï¼ˆå¦‚æœå¯ç”¨è”åŠ¨ï¼‰
            if (syncCharts) {
                otherChart.options.scales.x.min = newXMin;
                otherChart.options.scales.x.max = newXMax;
            }

            if (!isXAxisZoomMode) {
                const yMin = yScale.min;
                const yMax = yScale.max;
                const newYMin = mouseYValue - (mouseYValue - yMin) * zoomFactor;
                const newYMax = mouseYValue + (yMax - mouseYValue) * zoomFactor;
                chart.options.scales.y.min = newYMin;
                chart.options.scales.y.max = newYMax;
                
                // åŒæ­¥Yè½´ç¼©æ”¾ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (syncCharts && syncYAxis) {
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œé¿å…ç›´æ¥å¤åˆ¶Yè½´èŒƒå›´
                    const otherYScale = otherChart.scales.y;
                    const otherYRange = otherYScale.max - otherYScale.min;
                    const newYRange = newYMax - newYMin;
                    const ratio = newYRange / otherYRange;
                    
                    // ä¿æŒä¸­å¿ƒç‚¹çš„ç›¸å¯¹ä½ç½®
                    const otherYCenter = (otherYScale.max + otherYScale.min) / 2;
                    const newOtherYRange = otherYRange * zoomFactor;
                    
                    otherChart.options.scales.y.min = otherYCenter - newOtherYRange / 2;
                    otherChart.options.scales.y.max = otherYCenter + newOtherYRange / 2;
                }
            }

            chart.update('none');
            
            // å¦‚æœå¯ç”¨è”åŠ¨ï¼Œæ›´æ–°å¦ä¸€ä¸ªå›¾è¡¨
            if (syncCharts) {
                otherChart.update('none');
            }
        }

        // å¼€å§‹æ‹–åŠ¨æˆ–é€‰æ‹©
        function startDragging(e) {
            if (e.button !== 0) {
                e.preventDefault();
                return;
            }

            isDragging = true;
            const chart = e.target === document.getElementById('currentChart') ? currentChart : voltageChart;
            selectedChart = chart;

            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isSelectMode) {
                selectionStart = {
                    x: chart.scales.x.getValueForPixel(x)
                };
                selectionEnd = { ...selectionStart };
            } else {
                startX = x;
                startY = y;
                startXMin = chart.scales.x.min;
                startXMax = chart.scales.x.max;
                startYMin = chart.scales.y.min;
                startYMax = chart.scales.y.max;
            }
        }

        // æ‹–åŠ¨æˆ–é€‰æ‹©è¿‡ç¨‹
        function drag(e) {
            if (!isDragging || !selectedChart) return;
            
            const otherChart = selectedChart === currentChart ? voltageChart : currentChart;
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isSelectMode) {
                selectionEnd = {
                    x: selectedChart.scales.x.getValueForPixel(x)
                };
                selectedChart.update('none');
            } else {
                const dx = x - startX;
                const dy = y - startY;
                const chartArea = selectedChart.chartArea;
                const xRange = startXMax - startXMin;
                const yRange = startYMax - startYMin;
                
                const xShift = (dx / chartArea.width) * xRange;
                const yShift = (dy / chartArea.height) * yRange;
                
                selectedChart.options.scales.x.min = startXMin - xShift;
                selectedChart.options.scales.x.max = startXMax - xShift;
                selectedChart.options.scales.y.min = startYMin + yShift;
                selectedChart.options.scales.y.max = startYMax + yShift;
                
                // å¦‚æœå¯ç”¨è”åŠ¨ï¼ŒåŒæ­¥å¦ä¸€ä¸ªå›¾è¡¨çš„Xè½´èŒƒå›´
                if (syncCharts) {
                    otherChart.options.scales.x.min = startXMin - xShift;
                    otherChart.options.scales.x.max = startXMax - xShift;
                }
                
                selectedChart.update('none');
                
                // å¦‚æœå¯ç”¨è”åŠ¨ï¼Œæ›´æ–°å¦ä¸€ä¸ªå›¾è¡¨
                if (syncCharts) {
                    otherChart.update('none');
                }
            }
        }

        // ç»“æŸæ‹–åŠ¨æˆ–é€‰æ‹©
        function stopDragging() {
            if (!isDragging || !selectedChart) return;

            if (isSelectMode && selectionStart && selectionEnd) {
                const minX = Math.min(selectionStart.x, selectionEnd.x);
                const maxX = Math.max(selectionStart.x, selectionEnd.x);

                // åŒæ—¶é€‰æ‹©ä¸¤ä¸ªå›¾è¡¨ä¸­ç›¸åŒæ—¶é—´èŒƒå›´çš„æ•°æ®
                selectedMagneticData = dataBuffer.current.filter(point => 
                    point.x >= minX && point.x <= maxX
                );
                selectedVoltageData = dataBuffer.voltage.filter(point => 
                    point.x >= minX && point.x <= maxX
                );

                // æ›´æ–°ä¸¤ä¸ªå›¾è¡¨çš„é€‰æ‹©åŒºåŸŸæ˜¾ç¤º
                selectionStart = { x: minX };
                selectionEnd = { x: maxX };
                currentChart.update('none');
                voltageChart.update('none');

                if (selectedMagneticData && selectedMagneticData.length > 0 && 
                    selectedVoltageData && selectedVoltageData.length > 0) {
                    // å¯ç”¨åˆ†ææŒ‰é’®
                    document.querySelectorAll('.analysis-button').forEach(button => {
                        button.classList.add('enabled');
                        button.disabled = false;
                    });
                }
            }

            isDragging = false;
        }

        // æ¸…é™¤é€‰æ‹©
        function clearSelection(chart) {
            selectionStart = null;
            selectionEnd = null;
            selectedChart = null;
            selectedMagneticData = null;
            selectedVoltageData = null;
            
            // æ¸…é™¤ä¸¤ä¸ªå›¾è¡¨çš„æ‹Ÿåˆæ›²çº¿
            if (currentChart.data.datasets.length > 1) {
                currentChart.data.datasets.pop();
                currentChart.update();
            }
            if (voltageChart.data.datasets.length > 1) {
                voltageChart.data.datasets.pop();
                voltageChart.update();
            }

            // ç¦ç”¨åˆ†ææŒ‰é’®
            document.querySelectorAll('.analysis-button').forEach(button => {
                button.classList.remove('enabled');
                button.disabled = true;
            });

            // æ¸…é™¤åˆ†æç»“æœ
            analysisResults.innerHTML = '';
            analysisResults.classList.remove('show');
            
            // æ›´æ–°ä¸¤ä¸ªå›¾è¡¨
            currentChart.update();
            voltageChart.update();
        }

        // æ·»åŠ å…¨å±€å˜é‡
        let selectedMagneticData = null;  // ç”¨äºå­˜å‚¨é€‰ä¸­çš„ç£åœºæ•°æ®
        let selectedVoltageData = null;   // ç”¨äºå­˜å‚¨é€‰ä¸­çš„ç”µå‹æ•°æ®
        const analysisButtons = document.querySelectorAll('.analysis-button');
        const analysisResults = document.querySelector('.analysis-results');
        
        // æ–°å¢å˜é‡
        let extractedData = [];  // å­˜å‚¨æå–çš„æ•°æ®
        let currentColumn = 1;   // å½“å‰å¡«å……çš„åˆ—
        let lastAnalysisResult = null;  // å­˜å‚¨æœ€åä¸€æ¬¡åˆ†æç»“æœ
        let showFitLine = false; // æ˜¯å¦æ˜¾ç¤ºæ‹Ÿåˆçº¿

        // ä¿®æ”¹åˆ†ææŒ‰é’®çš„äº‹ä»¶ç›‘å¬
        analysisButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (!selectedMagneticData || selectedMagneticData.length === 0 || 
                    !selectedVoltageData || selectedVoltageData.length === 0) {
                    alert('è¯·é€‰æ‹©æ•°æ®åŒºåŸŸ');
                    return;
                }

                // æ¸…é™¤ä¹‹å‰çš„æ‹Ÿåˆæ›²çº¿
                if (currentChart.data.datasets.length > 1) {
                    currentChart.data.datasets.pop();
                    currentChart.update();
                }
                if (voltageChart.data.datasets.length > 1) {
                    voltageChart.data.datasets.pop();
                    voltageChart.update();
                }

                // è¿›è¡Œç»„åˆåˆ†æ
                const result = performCombinedAnalysis(selectedMagneticData, selectedVoltageData);
                lastAnalysisResult = result.data; // ä¿å­˜åˆ†æç»“æœæ•°æ®

                analysisResults.innerHTML = result.html;
                analysisResults.classList.add('show');
                
                // å¯ç”¨æå–æ•°æ®æŒ‰é’®
                const extractButton = document.getElementById('extractDataButton');
                if (extractButton && lastAnalysisResult) {
                    extractButton.disabled = false;
                    extractButton.classList.add('enabled');
                }
            });
        });



        // æ·»åŠ è‡ªåŠ¨ç¼©æ”¾å‡½æ•°
        function autoScaleCharts() {
            console.log('æ‰§è¡Œè‡ªåŠ¨ç¼©æ”¾...');
            
            // å¤„ç†ç”µæµå›¾è¡¨
            if (dataBuffer.current.length > 0) {
                const currentXValues = dataBuffer.current.map(point => point.x);
                const currentYValues = dataBuffer.current.map(point => point.y);
                
                const currentXMin = Math.min(...currentXValues);
                const currentXMax = Math.max(...currentXValues);
                const currentYMin = Math.min(...currentYValues);
                const currentYMax = Math.max(...currentYValues);
                
                // æ·»åŠ ä¸€äº›è¾¹è·
                const currentXPadding = (currentXMax - currentXMin) * 0.05;
                const currentYPadding = Math.max(0.2, (currentYMax - currentYMin) * 0.1);
                
                currentChart.options.scales.x.min = currentXMin - currentXPadding;
                currentChart.options.scales.x.max = currentXMax + currentXPadding;
                currentChart.options.scales.y.min = currentYMin - currentYPadding;
                currentChart.options.scales.y.max = currentYMax + currentYPadding;
                
                currentChart.update('none');
            }
            
            // å¤„ç†ç”µå‹å›¾è¡¨
            if (dataBuffer.voltage.length > 0) {
                const voltageXValues = dataBuffer.voltage.map(point => point.x);
                const voltageYValues = dataBuffer.voltage.map(point => point.y);
                
                const voltageXMin = Math.min(...voltageXValues);
                const voltageXMax = Math.max(...voltageXValues);
                const voltageYMin = Math.min(...voltageYValues);
                const voltageYMax = Math.max(...voltageYValues);
                
                // æ·»åŠ ä¸€äº›è¾¹è·
                const voltageXPadding = (voltageXMax - voltageXMin) * 0.05;
                const voltageYPadding = Math.max(0.2, (voltageYMax - voltageYMin) * 0.1);
                
                voltageChart.options.scales.x.min = voltageXMin - voltageXPadding;
                voltageChart.options.scales.x.max = voltageXMax + voltageXPadding;
                voltageChart.options.scales.y.min = voltageYMin - voltageYPadding;
                voltageChart.options.scales.y.max = voltageYMax + voltageYPadding;
                
                voltageChart.update('none');
            }
            
            console.log('è‡ªåŠ¨ç¼©æ”¾å®Œæˆ');
        }

        // æ·»åŠ ç»„åˆåˆ†æå‡½æ•°
        function performCombinedAnalysis(magneticData, voltageData) {
            try {
                // å¯¹ç£åœºæ•°æ®è¿›è¡Œçº¿æ€§æ‹Ÿåˆ
                const magneticFit = calculateLinearFitForData(magneticData, 'mT');
                
                // å¯¹ç”µå‹æ•°æ®è¿›è¡Œç»Ÿè®¡åˆ†æ
                const voltageStats = calculateStatisticsForData(voltageData, 'mV');
                
                // åœ¨ç£åœºå›¾è¡¨ä¸Šæ˜¾ç¤ºæ‹Ÿåˆçº¿
                if (currentChart.data.datasets.length > 1) {
                    currentChart.data.datasets[1].data = magneticFit.fittedData;
                } else {
                    currentChart.data.datasets.push({
                        label: 'ç£åœºçº¿æ€§æ‹Ÿåˆ',
                        data: magneticFit.fittedData,
                        borderColor: '#28a745',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false,
                        order: 0
                    });
                }
                
                currentChart.data.datasets[0].order = 1;
                currentChart.update();
                
                // è¿”å›ç»„åˆç»“æœï¼Œåˆ†ä¸¤è¡Œæ˜¾ç¤º
                const html = `
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                            <span style="color: #007bff; font-weight: bold; margin-right: 10px;">ç£æ„Ÿåº”å¼ºåº¦çº¿æ€§æ‹Ÿåˆ:</span>
                            <div class="result-item">æ‹Ÿåˆæ–¹ç¨‹: B = ${magneticFit.slope.toFixed(4)} Ã— t + ${magneticFit.intercept.toFixed(2)} mT</div>
                            <div class="result-item">æ–œç‡: ${magneticFit.slope.toFixed(4)} mT/s</div>
                            <div class="result-item">æˆªè·: ${magneticFit.intercept.toFixed(2)} mT</div>
                            <div class="result-item">RÂ²: ${magneticFit.rSquared.toFixed(4)}</div>
                        </div>
                        
                        <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                            <span style="color: #dc3545; font-weight: bold; margin-right: 10px;">æ„Ÿåº”ç”µåŠ¨åŠ¿ç»Ÿè®¡åˆ†æ:</span>
                            <div class="result-item">å¹³å‡å€¼: ${voltageStats.mean.toFixed(1)} mV</div>
                            <div class="result-item">æœ€å¤§å€¼: ${voltageStats.max.toFixed(1)} mV</div>
                            <div class="result-item">æœ€å°å€¼: ${voltageStats.min.toFixed(1)} mV</div>
                            <div class="result-item">æ•°æ®ç‚¹æ•°: ${voltageStats.count}</div>
                        </div>
                    </div>
                `;
                
                return {
                    html: html,
                    data: {
                        slope: Math.abs(magneticFit.slope), // æ–œç‡ç»å¯¹å€¼
                        voltage: voltageStats.mean // æ„Ÿåº”ç”µåŠ¨åŠ¿å¹³å‡å€¼
                    }
                };
            } catch (error) {
                console.error('ç»„åˆåˆ†æé”™è¯¯:', error);
                return {
                    html: '<p>åˆ†æè®¡ç®—å‡ºé”™ï¼Œè¯·æ£€æŸ¥æ•°æ®</p>',
                    data: null
                };
            }
        }
        
        // çº¿æ€§æ‹Ÿåˆè®¡ç®—å‡½æ•°
        function calculateLinearFitForData(data, unit) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            data.forEach(point => {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumXX += point.x * point.x;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // è®¡ç®—RÂ²
            const yMean = sumY / n;
            let ssTotal = 0, ssResidual = 0;
            
            data.forEach(point => {
                const yPred = slope * point.x + intercept;
                ssTotal += Math.pow(point.y - yMean, 2);
                ssResidual += Math.pow(point.y - yPred, 2);
            });
            
            const rSquared = 1 - (ssResidual / ssTotal);
            
            // ç”Ÿæˆæ‹Ÿåˆçº¿æ•°æ®
            const minX = Math.min(...data.map(p => p.x));
            const maxX = Math.max(...data.map(p => p.x));
            
            const fittedData = [
                { x: minX, y: slope * minX + intercept },
                { x: maxX, y: slope * maxX + intercept }
            ];
            
            return { slope, intercept, rSquared, fittedData };
        }
        
        // ç»Ÿè®¡åˆ†æè®¡ç®—å‡½æ•°
        function calculateStatisticsForData(data, unit) {
            const values = data.map(point => point.y);
            const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
            const max = Math.max(...values);
            const min = Math.min(...values);
            const count = values.length;
            
            return { mean, max, min, count };
        }


    </script>
</body>
</html>
